\documentclass[10pt,a4paper,draft]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[]{algorithm2e}
\usepackage{enumitem}
\usepackage{cite}
\setlist{
  noitemsep,
  listparindent=\parindent,
  parsep=0pt,
}
 	
\title{Smart Plans in Knowledge Bases}
\author{John Lennon}


\begin{document}

\maketitle

\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{Corrollary}{Corrollary}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{notation}{Notation}
\newtheorem{example}{Example}

\RestyleAlgo{boxruled}
\LinesNumbered


\section{Definitions}

\subsection{Linear Path}

\begin{definition}[Linear Path]
A path is said to be linear if it can be written with $n$ relations $r_1 ... r_n$ and has the form $P(X_1, ..., X_n) = r_1(X_1, X_2) ... r_n(X_n, X_{n+1})$.
\end{definition}

\begin{notation}
To simply, we will write $P = r_1 ... r_n$.
\end{notation}

\begin{definition}[Linear function]
A query or a function is said to be linear if it is a linear path. In what follows, we will always suppose that $X_1$ is the input of the function or the query, the other varibles being the outputs.
\end{definition}


\subsection{Smart Plans}

\begin{definition}[Smart Plan]
A plan $P$ is said to be smart if, for a given query $Q$ and for all knowledge bases $K$, either $P$ gives no result on $K$ or an answer of $Q$ in $K$ is among the results of calling $P$ for $K$. (We consider that if $Q$ has no answer at all on $K$, then a path is always smart on $K$).
\end{definition}

In what follows, we suppose that we have access to all intermediate outputs of a linear path.

\begin{property}
A linear smart plan $P$ for a linear query $Q = r_1 ... r_n$ is of the form $P = l_1 r_1 ... l_n r_n l_{n+1}$ where $l_1,..., l_n, l_{n+1}$ are linear paths.
\end{property}

\subsection{Fully Categorized Knowledge Base}

\begin{definition}[Fully Categorized Knowledge Base]
A knowledge base $K$ is said to be \textit{fully categorized} when for all $N_1, N_2$ nodes in $K$, we have:\\
\begin{center}
$Relations(N_1) \cap Relations(N_2) = \emptyset$ or $Relations(N_1) = Relations(N_2)$.
\end{center}
\end{definition}

This property means that, as soon as two nodes have at least one common relation, they must have identical relations.

\begin{definition}[Fully Categorized Knowledge Base Under a Set of Functions]
A knowledge base $K$ is said to be \textit{fully categorized} under a set $F$ of functions when for all $N_1, N_2$ nodes in $K$, we have:\\
\begin{center}
$Relations(N_1) \cap Relations(N_2) \subset \neg S$ or $Relations(N_1) \cap S = Relations(N_2) \cap S$.
\end{center}
where $S$ is the set of all relations used in all functions in $F$.
\end{definition}

It means that a knowledge base is fully categorized if we ignore all relations which are not used by functions in $F$.

\subsection{Way-Back Lists}

\begin{definition}[Way-Back List 1]
\label{Way-Back List 1}
A way-back list is a list recognized by the following algorithm.
\end{definition}

\begin{algorithm}[H]
 \SetAlgoLined
 \KwData{a list $l$ of relations}
 \KwResult{whether $l$ is a way-back list or not}
 $\sigma$ = empty stack\;
 \For {$c$ in $l$}{
  \If{$c$ == $head(\sigma)^{-1}$}{
   pop($\sigma$)\;
  }
  \Else{
   push($\sigma$, $c$)\;
  }
 }
 \If{$\sigma$ is empty}{
  \KwRet{$l$ is a way-back list.}
 }
 \Else{
  \KwRet{$l$ is not a way-back list.}
 }
 \caption{Way-Back Algorithm}
\end{algorithm}


\begin{definition}[Way-Back List 2]
\label{Way-Back List 2}
The way-back lists can be defined by the following context-free grammar:

\begin{itemize}[noitemsep]
\item Terminals: all possible relations $r$ in a knowledge base and their opposite $r^{-1}$.
\item Non-Terminals: $C$
\item Start Symbol: $S$
\item Relations:
\begin{itemize}[noitemsep]
\item $S \rightarrow C$
\item For all $r$ in the relations, $C \rightarrow CrCr^{-1}C$
\item  $C \rightarrow \epsilon$
\end{itemize}
\end{itemize}

\end{definition}


\begin{definition}[Way-Back List 3]
\label{Way-Back List 3}
The way-back lists can be defined by the following indexed grammar:
\begin{itemize}[noitemsep]
\item Terminals: all possible relations $r$ in a knowledge base and their opposite $r^{-1}$.
\item Non-Terminals: $C$
\item Start Symbol: $S$
\item Relations:
\begin{itemize}
\item $S \rightarrow C[]$
\item  $C[] \rightarrow \epsilon$
\item For all $r$ in the relations:
\begin{itemize}
\item $C[\sigma] \rightarrow C[\sigma r^{-1}] r$
\item $C[\sigma] \rightarrow C[\sigma] r C[r^{-1}]$
\item $C[\sigma] \rightarrow r C[r^{-1} \sigma]$
\item $C[\sigma] \rightarrow C[r^{-1}] r C[\sigma]$
\item $C[r \sigma] \rightarrow r C[\sigma]$
\end{itemize}
\end{itemize}
\end{itemize}
\end{definition}

\begin{theorem}
The definitions \ref{Way-Back List 1}, \ref{Way-Back List 2} and \ref{Way-Back List 3} are equivalent.
\end{theorem}

\begin{proof}
Let's call $L_1, L_2$ a,d $L_3$ the languages generated by definitions \ref{Way-Back List 1}, \ref{Way-Back List 2} and \ref{Way-Back List 3}. \\
Let $l$ be a list recognized by definition \ref{Way-Back List 1}. To find the associated rules that generate $l$ using definition \ref{Way-Back List 3}, we say that when an element $r$ is pushed on the stack, we use the rule $C[\sigma] \rightarrow r C[r^{-1} \sigma]$ and when an element is pulled from the stack, we use the rule $C[r \sigma] \rightarrow r C[\sigma]$. As at the end, the stack is empty, it also means that the stacks in the grammar are also empty (everything went out thanks to the last rule) and we can finish by doing $C[] \rightarrow \epsilon$. So, we have $L_1 \subseteq L_3$. \\
In the same way, we can transform the grammar rules into push/pop operations:
\begin{enumerate}
\item $C[\sigma] \rightarrow C[\sigma r^{-1}] r$: $r^{-1}$ was pushed and now we pop it, leaving the other operations on the left.
\item $C[\sigma] \rightarrow C[\sigma] r C[r^{-1}]$: we push $r$ and in the future we will pop it, leaving the other operations on the left.
\item $C[\sigma] \rightarrow r C[r^{-1} \sigma]$: we push $r$ and in the future we will pop it, leaving the other operations on the right.
\item $C[\sigma] \rightarrow C[r^{-1}] r C[\sigma]$: $r^{-1}$ was pushed and now we pop it, leaving the other operations on the right.
\item $C[r \sigma] \rightarrow r C[\sigma]$ allows the individual past and future pops and pushes.
\end{enumerate}
For example, if we consider the sequence:\\
$C[] \rightarrow^1 C[a^{-1}] a$ \\
$\rightarrow^2 C[a^{-1}] b C[b^{-1}] a$\\
$\rightarrow^5 a^{-1} b C[b^{-1}]a$\\
$\rightarrow^3 a^{-1} b c C[c^{-1} b^{-1}] a$ \\
$\rightarrow^4 a^{-1} b c C[d^{-1}] d C[c^{-1} b^{-1}] a$ \\
$\rightarrow^{3*5} a^{-1} b c d^{-1} d c^{-1} b^{-1} a$ \\
where $\rightarrow^i$ is the call to the $i^{th}$ rule in the grammar. The sequence can be transformed into: \\
$push_{TODO}(a^{-1}), pop(a)$ \\
$push_{TODO}(a^{-1}), push(b), pop_{TODO}(b^{-1}), pop(a)$ \\
$push(a^{-1}), push(b), pop_{TODO}(b^{-1}), pop(a)$ \\
$push(a^{-1}), push(b), push(c), pop_{TODO}(c^{-1}), pop_{TODO}(b^{-1}), pop(a)$ \\
$push(a^{-1}), push(b), push(c), push_{TODO}(d^{-1}), pop(d), pop_{TODO}(c^{-1}),$ \\
$pop_{TODO}(b^{-1}), pop(a)$ \\
$push(a^{-1}), push(b), push(c), push(d^{-1}), pop(d), pop(c^{-1}), pop(b^{-1}), pop(a)$ \\
At the end, the stack is empty because for all elements, we plan to pop it. It cannot get stuck (impossible to pop) by construction. So, we have $L_3 \subseteq L_1$ and then $L_1 = L_3$.\\
The same way, we can prove $L_1 = L_2$ by transforming the rules into push/pop operation on the stack.
\end{proof}

\begin{property}
We have the following properties.
\begin{enumerate}
\item The way-back lists are closed under concatenation: if $l_0$ and $l_1$ are way-back lists, then $l_0 l_1$ is also a way-back list.
\item \label{decompositionWBL} All list of relation l can be written $l = l_0 l_1 ... l_n$ where $l_i$ are alternatively way-back and not way back lists.
\end{enumerate}
\end{property}

\begin{theorem}
\label{comebacktheorem}
Let $l$ be a way-back list with parameters $X_1,...,X_n$. For all fully categorized knowledge bases $K$, if $l$ admits results, then $X_n = X_1$ is one of them.
\end{theorem}

\begin{lemma}
If l is a way-back list, then its length is $2*n$ with $n >= 0$.
\end{lemma}

\begin{proof}[Proof of the theorem]
Let $K$ be a fully categorized knowledge base. By induction we have: \\
If $|l| = 0$, nothing to say. \\
If $|l| = 2$, there exists a relation $r$ such that $l = r r^{-1}$ and then either $r$ is not a relation for $X_0$ and in this case $l$ admits no result or $X_0 = X_2$ is one of the solution. \\
If $|l| = 2*n$ and we suppose the theorem true for all lists $l'$ with a length strictly less than $2*n$. We remove the last element of $l$ and call it $c$. From the grammar definition of way-back lists, we can say that $l$ can be written $l = l_0 c^{-1} l_1 c$ where $l_0$ and $l_1$ are way-back lists. Using the theorem, we have, if $X_i$ is the output of $l_0$: $X_0 = X_i$ (from $l_0$) and $X_{i+1} = X_{2*n - 1}$ (from $l_1$). So, the problem can be reduced to $l = c^{-1} c$ where we have a set of inputs with $X_0$ among them. If $c$ is a relation of $X_0$, then we have $X_0 = X_{2*n}$ (see the case $|l| = 2$). If $c$ is not a relation of $X_0$ then, as $K$ is a fully categorized knowledge base, $c$ is not a relation for any of the inputs of $c$ (as all inputs share the relation before $c$) so $l$ admits no result.
\end{proof}

\begin{theorem}
\label{descriptiontheorem}
A plan $P = lQ$ (for a query $Q$ composed of one relation) is smart on fully categorized knowledge bases if and only if $l$ is a way-back list.
\end{theorem}

\begin{proof}
Let's suppose we have a way-back list $l$. Let $K$ be a fully categorized knowledge base where $Q$ has an answer on a node $X$. From theorem \ref{comebacktheorem}, we know that if we apply $l$ on $X$, either we have no result or $X$ is among results. If we have no result, we are done. If we do have results, if we apply $Q$ to these results, it be also applied to $X$ and so the result of calling $Q$ on $X$ is among results. We conclude that we have a smart plan.

Let's suppose now we have a list $l$ which is not a way-back list. From property \ref{decompositionWBL} about way-back lists, we can decompose $l$ into sublists. We write $l = l_0 l_1 ... l_n$ where $n > 0$ (as $l$ is not a way-back list). w.l.o.g. we can suppose that all $l_i$ where $i$ are even are way-back lists whereas all $l_i$ where $i$ are odd are not way-back lists. One can build a knowledge base where, starting from a node $X$, all way-back lists come back only to the starting node and non way-back lists only go to new nodes. In such a knowledge base, $P=lQ$ is not a smart plan.
\end{proof}


\begin{Corrollary}
A plan $P = l_1 r_1 ... l_n r_n $ (for a query $Q = r_1 ... r_n$) is smart on fully categorized knowledge bases if and only if $l_1$, ..., $l_n$ are way-back lists.
\end{Corrollary}

\section{Smart Plans with Functions}

\subsection{Rules}

\begin{definition}[Left Rules]
\label{leftrule}
A left rule will consume the beginning of a function. Let $f=r_1...r_n$ be a linear function. We call left rules extracted from $f$ the production rules (for an indexed grammar):
\begin{itemize}
\item $C[r_1...r_n \sigma] \rightarrow r_1 ... r_n C[\sigma]$
\item $C[r_1...r_{n-1} \sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} \sigma]$
\item ...
\item $C[r_1 \sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_2^{-1} \sigma]$
\item $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$
\end{itemize}
where $\sigma$ represents the stack.
\end{definition}

\begin{proof}
These are allowed indexed grammar rules. See \ref{reducedleftrules}.
\end{proof}

\begin{definition}[Right Rules]
\label{rightrule}
A right rule will consume the end of a function. Let $f=r_1...r_n$ be a linear function. We call right rules extracted from $f$ the production rules (for an indexed grammar):\\
For all $i \in [2, n]$, $C[r_i...r_n \sigma] \rightarrow C[r_{i-1}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$ \\
and $C[\sigma] \rightarrow C[r_{n}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$ \\
where $\sigma$ represents the stack.
\end{definition}

\begin{proof}
These are allowed indexed grammar rules. See \ref{reducedrightrules}.
\end{proof}

\subsection{Reduced Form Rules}

Although the rules are easier to understand with definitions \ref{leftrule} and \ref{rightrule}, it is more practical for algorithmic purposes to transform the rules into a reduce form.

\subsubsection{Reduced Left Rules}
\label{reducedleftrules}

Let $i \in [1; n]$. The associated rule is $C[r_1...r_i \sigma] \rightarrow r_1 ... r_n C[r_n^{-1}...r_{i+1}^{-1} \sigma]$. Let's transform it into reduced rules:
\begin{itemize}
\item $C[r_1 \sigma] \rightarrow B_1[\sigma]$
\item $B_1[\sigma] \rightarrow A_1[\sigma] C_2[\sigma]$
\item $A_1[\sigma] \rightarrow r_1$
\item $C_2[r_2 \sigma] \rightarrow B_2[\sigma]$
\item $B_2[\sigma] \rightarrow A_2[\sigma] C_3[\sigma]$
\item $A_2[\sigma] \rightarrow r_2$
\item ...
\item $C_i[r_i \sigma] \rightarrow B_i[\sigma]$
\item $B_i[\sigma] \rightarrow A_i[\sigma] C^{i+1}[\sigma]$
\item $A_i[\sigma] \rightarrow r_i$
\item $C_{i+1}[\sigma] \rightarrow A_{i+1}[\sigma] C_{i+2}[\sigma]$
\item $A_{i+1}[\sigma] \rightarrow r_{i+1}$
\item ...
\item $C_n[\sigma] \rightarrow A_n[\sigma] C^{back}[\sigma]$
\item $A_n[\sigma] \rightarrow r_n$
\item $C^{back}[\sigma] \rightarrow C^{back}_{i+1}[\sigma] T[\sigma]$
\item $C_{i+1}^{back}[\sigma] \rightarrow C^{back}_{i+2}[c^{-1}_{i+2} \sigma]$
\item ...
\item $C_{n}^{back}[\sigma] \rightarrow C^{back}_{n+1}[c^{-1}_{n} \sigma]$
\item $C^{back}_{n+1}[\sigma] \rightarrow C[\sigma] T[\sigma]$
\item $T[\sigma] \rightarrow \epsilon$
\end{itemize}

Here, we have a total of $4 * n - i + 1$ rules.

\subsubsection{Reduced Right Rules}
\label{reducedrightrules}

Let $i \in [2; n]$. The associated rule is $C[r_i ... r_n \sigma] \rightarrow C[r_{i-1}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$. Let's transform it into reduced rules:
\begin{itemize}
\item $C[c_i \sigma] \rightarrow B[\sigma]$
\item $B[\sigma] \rightarrow A_1[\sigma] D[\sigma]$
\item For all relations $r$, $A_1[r \sigma] \rightarrow A_1[\sigma]$ (the stack is emptied).
\item $A[] \rightarrow A^{back}_{0}[\sigma]$
\item $A^{back}_{0}[\sigma] \rightarrow A^{back}_{1}[r_1^{-1} \sigma]$
\item ...
\item $A^{back}_{i-2}[\sigma] \rightarrow C[r_{i-1}^{-1} \sigma]$
\item $D[\sigma] \rightarrow E_1[\sigma]C_{i+1}[\sigma]$
\item $C_{i+1}[r_{i+1} \sigma] \rightarrow C_{i+2}[\sigma]$
\item ...
\item $C_{n}[r_{n} \sigma] \rightarrow C[\sigma]$
\item $E_1[\sigma] \rightarrow F_1[\sigma] E_2[\sigma]$
\item ...
\item $E_n[\sigma] \rightarrow F_n[\sigma] E_{n+1}[\sigma]$
\item $E_{n+1}[\sigma] \rightarrow \epsilon$
\item $F_1[\sigma] \rightarrow r_1$
\item $F_n[\sigma] \rightarrow r_n$
\end{itemize}

Here, we have a total of ($\textrm{Number relations} + 3 * n + 4$) rules.

\subsubsection{Total Number of Rules}

Let $f_1 ... f_k$ be k linear functions with respectively $n_1, ..., n_k$ relations. Let $R$ be the set of all relations (it can be reduced to the set of relations used by the $f_i$s as only them can be pushed on the stack). For $i \in [0; k-1]$,
\begin{itemize}
\item $f_i$ has $n_i$ left rules, so a total after reducing of $\sum\limits_{j=1}^n [4 * n_i - j + 1] = \mathcal{O}(n_i^2)$
\item $f_i$ has $n_i - 1$ right rulesn so a total after reducing of $\mathcal{O}(n_i * |R| - |R| + n_i^2)$
\end{itemize}

At the end, if we sum for all functions and we have $n = n_1 = ... = n_k$ , we have $\mathcal{O}(k*(n^2 + n * |R|))$ relations. If $|R| = \mathcal{O}(n)$ then we have $\mathcal{O}(k * n^2)$ relations.

\subsection{Problem}

Given a set of linear functions $F$, is it possible to know whether there exists a smart plan which only uses functions in $F$.\\
(give further explanations, examples...)

\begin{hypothesis}
\label{intermediatefunctions}
In what follows, we assume that if we can call a linear function $f = r_1 ... r_n$ then we can also call the functions $f_i = r_1 ... r_i$ for $i \in [1; n]$.

\end{hypothesis}

\subsection{Algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A set of functions $F$ and a linear query $q$}
\KwResult{whether there exists a smart plan composed only of calls to functions in $F$}
Replace all functions $f$ in $F$ by a their subfunctions as describe in hypothesis \ref{intermediatefunctions}\;
Create an indexed grammar as follows:
\begin{itemize}
\item $S \rightarrow C[q]$
\item $C[] \rightarrow \epsilon$
\item For all functions $f \in F$, derive the left rules and right rules in their reduced form as describes in \ref{reducedleftrules} and \ref{reducedrightrules} (the C is common to all rules).
 \end{itemize}
 \KwRet{Whether $L(G) = \emptyset$ or not using the algorithm described in \cite{aho68}}
 \caption{Algorithm Smart Plan From a Set of Functions}
 \label{functionWBLAlgo}
\end{algorithm}

\begin{proof}
\textit{Correctness}: Let's show that only smart plans are generated. To do so, we can transform left and right rules into way-back list rules as shown in definition \ref{Way-Back List 3}. We will prove the case of left rules.\\
Let $n$ be an integer, $i \in [1, n]$ and let's consider the left rule $C[r_1...r_i \ sigma] \rightarrow r_1 ... r_n C[r_n^{-1} ... r_{i+1}^{-1} \sigma]$. The rule can be transformed into:
\begin{itemize}
\item $C[r_1 \sigma] \rightarrow r_1 C_2[\sigma]$
\item ...
\item $C_i[r_i \sigma] \rightarrow r_i C_{i+1}[\sigma]$
\item $C_{i+1}[\sigma] \rightarrow r_{i+1} C_{i+1}[r_{i+1}^{-1} \sigma]$
\item ...
\item $C_n[\sigma] \rightarrow r_n C[r_n^{-1} \sigma]$
\end{itemize}
Let $n$ be an integer, $i \in [1, n]$ and let's consider the right rule $C[r_i...r_n \ sigma] \rightarrow C[r_{i-1}^{-1} ... r_{1}^{-1}] r_1 ... r_n C[\sigma]$. The rule can be transformed into:
\begin{itemize}
\item $C[\sigma] \rightarrow C_1[r_{i-1}^{-1}] r_{i-1} C_1'[\sigma]$
\item $C_1[\sigma] \rightarrow C_2[\sigma r_{i-2}^{-1}] r_{i-2}$
\item ...
\item $C_{i-1}[\sigma] \rightarrow C[\sigma r_1^{-1}] r_1$
\item $C_1[r_i \sigma] \rightarrow r_i C_2'[\sigma]$
\item ...
\item $C_{n - i + 1}[\sigma] \rightarrow r_n C[\sigma]$
\end{itemize}
As both left and right rules can be written as rules which are rules extracted from definition \ref{Way-Back List 3}, we conclude that we will generate plans $P = l$ where l is a way-back list and if $q$ is composed of no relation.

\begin{lemma}
\label{formWordsGrammar}
$C[r_1 ... r_n]$ will generate lists of the form $l_0 r_1 l_1 ... r_n l_n$ where $l_0$, ..., $l_n$ are way-back lists.
\end{lemma}

\begin{proof}
Let's say we modify the starting symbol to $S \rightarrow r_1^{-1} ... r_n^{-1} C[r_1 ... r_n]$. This way, we have a way-back list rule. So, we will generate way-back lists beginning by $r_1^{-1} ... r_n^{-1}$, it means that it generates words of the form $r_1^{-1} ... r_n^{-1} l_0 r_1 l_1 ... r_n l_n$ and so $C[r_1 ... r_n]$ generates lists of the form $l_0 r_1 l_1 ... r_n l_n$.
\end{proof}

So by calling $C[q_1 ... q_n]$, we have results of the form $P = l_0 q_1 l_1 ... q_n l_n$ and by using hypothesis \ref{intermediatefunctions}, we have access to all the required $q_i$. As shown in theorem \ref{descriptiontheorem}, if we have a fully categorized knowledge base, $P$ is a smart plan.\\

\textit{Completeness}: The grammar can be seen as an exhaustive search: at each production rule call, we try to call all functions. These functions can either consume relations which were required and give additional ones or asked in the future for given relations to be able to be called. Notice that function can be called even if nothing is required with $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$ and $C[\sigma] \rightarrow C[r_{n}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$ in order to be exhaustive.
\end{proof}

\subsection{Reducing Constraints}

As we saw before, a fully categorized knowledge base is required to be able to apply the results. However, when using functions calls, not all constraints are needed as some relations are never used. So, a fully categorized knowledge base under the given set of functions can be used.\\
One can also notice that relations cannot be called in any order. This order is determined by the set of functions. So, it is possible to extract axioms from a set of functions which need to be true in the knowledge base.\\
Let $F = f_1 ... f_n$ a set of linear functions.
Let $f \in F$ be a linear function with $f = a_1 ... a_n$, $n > 1$. We can deduce the following axioms:
\begin{itemize}
\item For all $i \in [1, n-1]$, $a_i \Leftrightarrow a_{i+1}$ is true for all nodes or is false for all nodes (i.e. $a_i \Leftrightarrow \neg a_{i+1}$ is true for all nodes).
\item Let $f_1 = a_1 ... a_n$ and $f_2 = b_1 ... b_m$ be two functions from $F$ ($n \geq 1$ and $m \geq 1$). We have: $a_n \Leftrightarrow b_1$ is true for all nodes or is false for all nodes (i.e $a_n \Leftrightarrow \neg b_1$ is true for all nodes).
\end{itemize}

These axioms can be reduced even more, without having to assume the transition between functions.

\begin{hypothesis}
\label{implyfunction}
Given a set of function $F$ and a knowledge base $K$, we suppose we have for all $f \in F$, $f = a_1 ... a_n$, $n > 1$: \\
For all $i \in [1, n-1]$, $a_{i}^{-1} \Leftrightarrow a_{i+1}$ is true for all nodes in $K$ or is false for all nodes in $K$ (i.e. $a_{i}^{-1} \Leftrightarrow \neg a_{i+1}$ is true for all nodes in $K$).\\
\end{hypothesis}

\begin{theorem}
\label{implyaxiomtheorem}
With hypothesis \ref{implyfunction}, the algorithm \ref{functionWBLAlgo} gives whether there exists a smart plan or not (but the grammar used in algorithm \ref{functionWBLAlgo} might generate non-smart plans).
\end{theorem}

\begin{proof}

\begin{definition}[Function Loop]
Let $\mathcal{F}$ be a set of linear functions and $l = f_1 ... f_n$ ($f_1,...,f_n$ are functions in $\mathcal{F}$) be a list of relations built with $\mathcal{F}$. We call a function loop a sequence of function from $l$, $f_i ... f_j$ ($i < j$) such that $f_i ... f_j$ is a way-back list.
\end{definition}

\begin{lemma}
If the grammar used in algorithm \ref{functionWBLAlgo} generates a non-empty answer, there exists at least one solution without a function loop.
\end{lemma}

\begin{proof}

Let $lq$ be the shortest (in term of number of relations) non-empty word of the grammar in the algorithm \ref{functionWBLAlgo} for a query $q$ (of length 1 to simplify). We saw that $l$ is a way-back list. $l$ can be written $l = f_1 ... f_n a_1 ... a_k$ ($a_1,...,a_k$ are the first relations of the last function $f_{n+1} = a_1 ... a_k q$). $l$ does not strictly contain function loops, meaning that there exists no $i,j \in [1, n], i<j$ such that $f_i ... f_j$ is a way-back list. Otherwise, the shortest word would be $l = f_1 ... f_{i-1} f_{j+1} ... f_n$.

\end{proof}

%Let $l$ be a wayback list without a function loop. As we have no loop, it is not possible to have two functions ending on the same node. In other words, it can happen only once that we are not sure whether a function can be called on a node or not; in all other cases, if the node is reached, it can be exited.\\


%Let's consider a node (intermediate or not) $N$ reached when calling $l$. Then, if we only consider relations used by $N$ during the call of $l$, these relations $R_N$ can be partitionned into several group of relations $R_N = R_N^1 \cup ... \cup R_N^p$ with for each $i \in [1; p]$ and each $r_1, r_2$ in $R_N^i$, $r_1 \Leftrightarrow r_2$ (from axioms in hypothesis \ref{implyfunction}) but if we have $r_1$ and $r_2$ from two different groups, $r_{1} \Leftrightarrow r_{2}$ is not an axiom deduced from hypothesis \ref{implyfunction}.\\


%Let's suppose that there is a function that stops at $N$ (otherwise, we have no problem). We call the relation before the stop $r_1$ and the relation after the stop $r_2$. If $r_1^{-1}$ and $r_2$ are in the same group of relation, we have no problem: we have $r_{1}^{-1} \Leftrightarrow r_{2}$ and the transission always exists. We now suppose there are in two different groups, w.l.o.g. $R_N^1$ and $R_N^2$. The problem can be reduced to $R_N = R_N^1 \cup R_N^2$ as communications between two other groups are impossible (again as one can stop only once at a node). As $R_N^1$ and $R_N^2$ are disctinct $r_{1}^{-1} \Leftrightarrow r_{2}$ is not an axiom given by hypothesis \ref{implyfunction} or by a combination of axioms in hypothesis \ref{implyfunction} (i.e. $r_{1}^{-1} \Leftrightarrow ... \Leftrightarrow r_{2}$).\\

%Let $K$ be a knowledge base. If $lq$ gives no result on $K$ then we have nothing to say. Let's suppose now that $lq$ gives results on $K$. Let $N_0$ be the first node that appears when stacking a relation $r$ but do not appear when unstacking $r$ (meaning when we call the corresponding $r^{-1}$, here we consider the first one to disappear, i.e. when calling $r^{-1}$). Let's call $\mathcal{N}_1$ the set of nodes we have before calling $r$ and $\mathcal{N}_2$ the set of nodes we have after calling $r^{-1}$. Let $N \in \mathcal{N}_1$. If $r$ is not a relation of $N$, it is trivial $N$ is not a relation of $\mathcal{N}_2$, except by chance. Let's suppose $N$ has $r$ as a relation. As the first nodes to disappear are after $r^{-1}$, it means no node disappear between $r$ and $r^{-1}$ so $N \in \mathcal{N}_2$.\\

%\begin{lemma}
%Let $K$ be a knowledge base. Let $l$ be a way-back list of the form $r l_0 r^{-1}$. Let $r$ be a relation from $l$ such as $l = l_0 r l_1 r^{-1} l_2$ with $length(l_0) > 0$ (i.e. $r$ is not the first relation). Let $N_r$ be the set of nodes we have after calling $l_0$ on $K$ and $N_r^{-1}$ be the set of nodes we have after calling $l_0 r l_1 r^{-1}$. We suppose we have $N_r \subset N_r^{-1}$. Then, all nodes to which we apply $l$ and which have the first relation of $l$ (otherwise we have no result at all) are also in the output nodes of $l$.
%\end{lemma}

%\begin{proof}
%Let $l$ be a way-back list. We suppose the lemma is true for all lists of length strictly less than $2*n$. In the worst case, we can write $l = a c l_0 c^{-1} d l_1 d^{-1} a^{-1}$. We apply the hypothesis on $c l_0 c^{-1}$ $d l_1 d^{-1}$: we have $N_c \subset N_c^{-1} = N_d \subset N_d^{-1}$.
%\end{proof}


\begin{lemma}
Let $K$ be a knowledge base, $\mathcal{F}$ a set of linear functions and $l = f_1 ... f_n$ ($f_1,...,f_n$ are functions in $\mathcal{F}$) be a way-back list built with $\mathcal{F}$ without a function loop different from $l$. Let $r$ be a relation from $l$ such that $l = l_0 r l_1 r^{-1} l_2$. Let $\mathcal{N}_1$ be the set of nodes obtained by calling $l_0$ on $K$ and $\mathcal{N}_1^r$ the set of nodes in $\mathcal{N}_1$ which have a $r$ relation. Let $\mathcal{N}_2$ be the set of nodes optained after calling $l_0 r l_1 r^{-1}$. Then, under hypothesis \ref{implyfunction}, we have $\mathcal{N}_1^r \subseteq \mathcal{N}_2$ or $\mathcal{N}_2 = \emptyset$.
\end{lemma}

\begin{proof}
Let's prove the lemma by induction on the number $n$ of relations between $r$ and $r^{-1}$.\\
For $n = 0$, we have $r r^{-1}$ and the result is obvious. \\

Let $n > 0$. We consider that the lemma is true for all $k < n$. We write $l = l_0 r r_1 l_1 r_1^{-1} r_2 l_2 r_2^{-1} ... r_k l_k r_k^{-1} r^{-1} l_{k+1}$ ($l_0, ..., l_k$ are way-back lists by construction) where we have $n$ relations between $r$ and $r^{-1}$. We call $\mathcal{N}^i$ the set of nodes obtained before calling $r_i$ and $\mathcal{N}^{k+1}$ the set of nodes obtained before calling $r^{-1}$.\\

Let's prove that $\mathcal{N}^{1, r_1} \subseteq \mathcal{N}^{k+1, r^{-1}}$ ($\mathcal{N}^{1, r_1}$ is the subset of $\mathcal{N}^{1}$ with the relation $r_1$ and $\mathcal{N}^{k+1, r^{-1}}$ the subset of $\mathcal{N}^{k+1}$ with the relation $r^{-1}$).\\

If a function stops on $r$, no function (used in $l$) can stop on $r_1^{-1}$ nor on any $r_i^{-1}$ (otherwise there would be a loop as $r_1 l_1 r_1^{-1}$ and all the $r_1 l_1 r_1^{-1} ... r_i l_i r_i^{-1}$ are way-back lists). With the induction hypothesis, we have $\mathcal{N}^{i, r_{i+1}} \subseteq \mathcal{N}^{i+1}$ for all $i > 1$. As we do not stop as described before, we have $\mathcal{N}^i = \mathcal{N}^{i, r_{i+1}}$. So, we have $\mathcal{N}^{1, r_1} \subseteq \mathcal{N}^{k+1, r^{-1}}$.\\

Now we suppose we do not stop on $r$ but a function stops on $r_j^{-1}$ with $ 1 < j < k$. For the same reasons than before, no function can stop on any $r_i^{-1}$ ($ i \neq j$). It means that, for $i \neq j$, we have at least one function which contains $r_i^{-1} r_{i+1}$ and $r_k^{-1} r^{-1}$. So, from hypothesis \ref{implyfunction}, we have for $i \neq j$, $r_i \Leftrightarrow r_{i+1}$, $r_k \Leftrightarrow r^{-1}$ and $r^{-1} \Leftrightarrow r_1$ (no stop on $r_1$). If one of the axioms is that $a_{i}^{-1} \Leftrightarrow \neg a_{i+1}$ is true for all nodes in $K$, then we have no result at all, i.e. $\mathcal{N}_2 = \emptyset$. We consider it is not the case. By transitivity, we also have $r_j \Leftrightarrow r_{j+1}$ and we have the transition $r_j^{-1} r_{j+1}$ for all nodes. Using the same arguments than before, $\mathcal{N}^{1, r_1} \subseteq \mathcal{N}^{k+1, r^{-1}}$.\\

Then, we can conclude that $\mathcal{N}_1^r \subseteq \mathcal{N}_2$.
\end{proof}


\begin{Corrollary}
\label{cornoloop}
Let $K$ be a knowledge base, $\mathcal{F}$ a set of linear functions and $l = f_1 ... f_n$ ($f_1,...,f_n$ are functions in $\mathcal{F}$) be a way-back list built with $\mathcal{F}$ without a function loop different from $l$. Then, either $l$ gives no result on $K$ or the input is also among the outputs of $l$.
\end{Corrollary}

We know that if there are words in the grammar in algorithm \ref{functionWBLAlgo}, then there are words without function loop in them and we proved with corrollary \ref{cornoloop} that a word without a loop is a smart plan. So there is at least one smart plan amoung the words. In addition, as all smart plans are way-back lists, all of them are in the grammar. So, the algorithm \ref{functionWBLAlgo} still gives us whether there exist smart plans or not.

\end{proof}


\section{Reducing the Grammar}

As we proved in theorem \ref{implyaxiomtheorem}, one could remove all the loops and still obtain the same result after algorithm \ref{functionWBLAlgo}. Then, would it be possible to remove rules from the grammar that add nothing but function loops? By doing so, we hope to reduce the computation time of algorithm \ref{implyaxiomtheorem} and of the exploration to find a plan. However, we might lose the completeness of the grammar but it does not change the result of the algorithm \ref{functionWBLAlgo}.\\

\begin{theorem}
By removing the rules:
\begin{itemize}
 \item $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$
 \item $C[\sigma] \rightarrow C[r_{n}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$
\end{itemize}
only plans with function loops are removed.
\end{theorem}

\begin{proof}
Let consider the rule $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$. This rule means that a function is called without using anything on the stack. Using this rule may generate a loop between $r_1$ and $b$, where $b$ was the symbol at the top of the stack when the rule was called. Let suppose it is not the case. It means that a function will be called such that  $a b$ (where $a$ is a relation) is a part of that function. Let's call this function $f = x_1 ... x_k a b y_1 .. y_l$.\\
Instead of calling $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$, we call the rule associated with $f$: $C[b y_1 ... y_k]$. Using lemma \ref{formWordsGrammar} and completeness, we know we get all possible words of the for $r_1 ... r_n l_0 r_1 l_1 ... r_n l_n b y_1 l_1^2... y_k l_k^2$ which are makable and in particular, what should have appeared with the rule we have just erased. If we still obtain a rule of the form $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$, we redo the same operation and it will end as $f$ is finite.\\
Then, all rules of the form $C[\sigma] \rightarrow r_1 ... r_n C[r_{n}^{-1} ... r_1^{-1} \sigma]$ which do not create loops can be erased by deleting first the outer ones so the procedure ends.\\
For the rule $C[\sigma] \rightarrow C[r_{n}^{-1} ... r_1^{-1}] r_1 ... r_n C[\sigma]$, only results with function loops are created as a function ends on $r_n$, $C[r_{n}^{-1} ... r_1^{-1}]$ generate lists of the form $r_{n}^{-1} l_n ... r_1^{-1} l_1$ ($l_1$ ... $l_n$ are way-back lists) and $r_{n}^{-1} l_n ... r_1^{-1} l_1 r_1 ... r_n$ is a way-back list.\\
We conclude only plans with function loops are removed.
\end{proof}

\section{Algorithm}

\subsection{Introduction}
\label{introAlgo}

The algorithm presented in \cite{aho68} has a disadvantage: a set of rules is generated before actually applying the algorithm. The size of this set is exponential. So, at the end the algorithm has an exponential complexity even in the best case. For computational purposes, it is great to lower this bound, even if the upper bound is still exponential.

We propose here to generate the rules on the fly so we do not generate useless rules. To apply the algorithm, as in \cite{aho68}, we need rules in their reduced form. More precisely, they should be either a production, a consumption, a duplication or an end rule.

\begin{definition}[Production Rule]
We call "production rules" rules of the form:

$A[\sigma] \rightarrow B[f \sigma]$

where $A$ and $B$ are non-terminals, $f$ is a production symbol (here production symbols are the terminals) and $\sigma$ is the stack.
\end{definition}

\begin{definition}[Consumption Rule]
We call "consumption rules" rules of the form:

$A[f \sigma] \rightarrow B[\sigma]$

where $A$ and $B$ are non-terminals, $f$ is a production symbol (here production symbols are the terminals) and $\sigma$ is the stack.

In what follows, we call $Cons(f)$ the set of all the consumption rules which use $f$ as a production symbol.
\end{definition}

\begin{definition}[Duplication Rule]
We call "duplication rules" rules of the form:

$A[\sigma] \rightarrow B[\sigma] C[\sigma]$

where $A$, $B$ and $C$ are non-terminals and $\sigma$ is the stack.
\end{definition}

\begin{definition}[End Rule]
We call "end rules" rules of the form:

$A[\sigma] \rightarrow a$

where $A$ is a non-terminals, $a$ is a terminal and $\sigma$ is the stack.
\end{definition}

\subsection{Initialization}
\label{initAlgo}

Instead of writting all the rules presented in \cite{aho68}, we keep track of all marked sets. We initialize the algorithm as follows:

\begin{enumerate}
\item $marked \leftarrow dictionary()$, $marked$ gives for all non-terminal the sets which are marked.
\item For all non-terminals $A$, $marked[A] = List()$
\item For all non-terminals $A$, $marked[A].append(set(A))$
\item For all end rules $A[\sigma] \rightarrow a$, $marked[A].append(set())$ 
\end{enumerate}

Then, we will loop on the rules until no more new sets are marked. During the loop, we process duplication and production rules differently.

\subsection{Duplication Rule Processing}
\label{processDuplication}

For the duplication rule $A[\sigma] \rightarrow B[\sigma] C[\sigma]$, we mark for $A$ all the $N_B \cup N_C$ where $N_B$ is marked for $B$ and $N_C$ is marked for $C$.

\subsection{Production Rule Processing}
\label{processProduction}

For the production rule $A[\sigma] \rightarrow B[f \sigma]$:
\begin{enumerate}
\item If there exists a rule of the form $B[f \sigma] \rightarrow C[\sigma]$ (where $C$ is a non-terminal) in $Cons(f)$ then:
\begin{enumerate}
\item For $A$, mark all the $N_B$ where $N_B$ is marked for $B$.
\item If the empty set is marked for $B$, for all rules $D[f \sigma] \rightarrow E[\sigma]$, mark for $A$ all the $N_E$ where $N_E$ is a set marked for $E$.
\end{enumerate}
\item For all marked sets for $B$ $N_B = \{C_1, C_2, ..., C_r\}$, for all combinations of rules from $Cons(f)$ $C_1[f \sigma] \rightarrow D_1[\sigma]$, ..., $C_r[f \sigma] \rightarrow D_r[\sigma]$ (we need exactly only rule for each $C_i$), mark for $A$ $N = \cup_{i=1}^{r} N_{D_i}$ for all $N_{D_i}$ marked for $D_i$ ($1 \leq i \leq r$)
\end{enumerate}

\subsection{Final Algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{a set of rules in reduced form (\ref{introAlgo})}
\KwResult{whether the grammar is empty or not}
Initialize the algorithm (\ref{initAlgo})\;
\While{new sets are marked}{
\For {each rule}{
  \If{the rule is a duplication rule}{
   do the processing for duplication rule (\ref{processDuplication})\;
  }
  \ElseIf{the rule is a production rule}{
   do the processing for production rule (\ref{processProduction})\;
  }
 }
 }
 \KwRet{the grammar is not empty if and only if the empty set is marked for $S$}
 \caption{Algorithm Emptyness Indexed Grammar}
 \label{algoEmptyness}
\end{algorithm}


\bibliographystyle{plain}
\bibliography{./smart_plans.bib}

\end{document}